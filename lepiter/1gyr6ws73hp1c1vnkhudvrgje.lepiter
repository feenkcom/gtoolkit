{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T09:59:21.570525-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:04:19.379946-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "Vt6uCfr9DQCK/MRaBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Pharo code can be transformed using the {{gtClass:RBParseTreeRewriter}} class. In its basic form, you can specify an expression using {{gtMethod:RBParseTreeRewriter>>replace:with:}} and then use the {{gtMethod:RBParseTreeRewriter>>executeTree:}} method to transform the tree.  In the following example, we transform all occurrances of `collection at: 2` to be `collection second`."
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:09:15.229547-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:09:15.229547-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "fF0dNPr9DQCSqtyEBvTZGA=="
				},
				"exampleSelector" : "rewriteToSecond",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:29:34.911329-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:42:57.868689-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "HnrDWvr9DQCS1eoDBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The real power of the rewriter is when you start using patterns to match code. Patterns start with a backquote character and contain a name.  In the following example, we extend the previous example to match any variable node instead of only `collection`."
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:43:03.703262-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T10:43:03.703262-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "CWsFrfr9DQCcOQykBvTZGA=="
				},
				"exampleSelector" : "rewriteVariableAtTwoToSecond",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:31:53.678051-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:36:28.341717-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "fUmpW/v9DQCcQMopBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Matching any variable is good, but sometimes we want to be able to match any expression object. For these cases, we can add a `@` character to our pattern node. In the following example, we modify the previous rewrite to take any expression as the receiver of the `at: 2` message:"
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:38:12.187367-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:38:12.187367-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "HeE4cvv9DQCjP6qeBvTZGA=="
				},
				"exampleSelector" : "rewriteAtTwoToSecond",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:39:01.974714-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:48:23.944841-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "65Iwdfv9DQCjQ70nBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "When a match is found, the rewriter creates a new AST based on the replacement pattern AST. When a pattern node is used in the replacement, it copies node that was matched by the pattern node in the search pattern. One question that can arise when the replacement occurs is what should happen if the AST matching a pattern node contains other matches. Should we continue replacements in these AST nodes, or should we only replace at the top level? By default, the rewriter only replaces nodes at the top level. Therefore, if you were to run the rewriter from the previous example on an expression like `(collection at: 2) at: 2`, you would get `(collection at: 2) second`. The inner `at: 2` message would not be rewritten. Adding a second backquote character to the pattern node, makes the rewriter recursively look for more matches inside the pattern node being copied: "
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:49:23.941567-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-20T11:49:23.941567-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "4whDmvv9DQC3MLGpBvTZGA=="
				},
				"exampleSelector" : "rewriteAllAtTwoToSecond",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T05:35:52.488907-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T05:43:36.358151-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "LshGgAr+DQC+CrdZBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "In addition to matching variables and any object expression, we can also match just literal nodes by using the hash (`#`) character. In the following example, we add a `printString` message send to each top level literal node. If we used double backquote in the literal pattern, we would search inside of the literal array to find more matches."
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T05:43:42.243266-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T05:43:42.243266-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "CKpGnAr+DQCGLF1qBvTZGA=="
				},
				"exampleSelector" : "literalMatches",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T06:23:54.998118-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T06:27:28.476001-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "+RzfKAv+DQCGy1dpBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Using patterns, we can also match message sends where we don't know the selector or number of arguments. If we use the backquote and `@` with an argument, we can match any message send. For example, suppose we wish to perform a rewrite where messages sent to a variable (`collection`) go through an accessor method. If the variable is not a receiver of message, then we should not convert it to use the accessor. In this case, we can match any message sent to the variable and only rewrite those matches."
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T06:29:48.45434-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T06:29:48.45434-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "7LEnQQv+DQCTG6nYBvTZGA=="
				},
				"exampleSelector" : "rewriteToAccessorWhenReceiverOfMessage",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T06:47:09.505099-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:01:59.226094-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "kt40fwv+DQCTJ0veBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Cascade messages are another type of node that has a custom rewrite syntax. Adding a `;` character to a pattern message in a c ascade makes it match any message. If it is combined with an `@` character, then it matches 0 or more messages that occur in the cascade. In the following example, we create a rewrite that swaps two `add:` messages in a cascade."
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:02:05.447085-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:02:05.447085-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "5dubtAv+DQCbZx1yBvTZGA=="
				},
				"exampleSelector" : "swapAddMessages",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:36:02.981604-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:44:42.554032-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "y23pvQv+DQCbbAdDBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Sometimes just matching the AST structure isn't enough, we may want to do a little more testing before deciding to perform a rewrite. The rewriter allows one to use `{} pattern code blocks to further limit what matches. On the searching side, each pattern code block takes two arguments. The first argument is the node that is being matched, and the second is a dictionary that contains the pattern matches that have been made. The pattern block returns true if it matches, and false otherwise. On the replacement side, the pattern block takes a single dictionary argument and returns a program node object. In the following code, we only rewrite \"isOpaque\" messages to \"isTranslucent not\" if they are sent to something that looks like a color (i.e., has *color* in the source):"
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:44:57.914845-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:44:57.914845-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "65nwTQz+DQCunE7TBvTZGA=="
				},
				"exampleSelector" : "convertColorIsOpaque",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T07:45:48.656749-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:17:13.241675-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "lNz2UAz+DQCuofTpBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The search pattern block nodes can also be used like a message sent to a node. In these cases, the pattern block node argument is the node that was matched to the receiver. As an example, consider this alternative for the previous example that uses a pattern message block and makes the rewrite expression simpler:"
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:17:16.344921-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:17:16.344921-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "dLJ6wQz+DQC2GWa9BvTZGA=="
				},
				"exampleSelector" : "convertColorIsOpaqueAlternative",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:22:48.723307-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:45:31.611951-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "2mNK1Qz+DQC2HoyJBvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "So far we have only looked at replacing expressions, but sometimes we need to work across multiple statements in the search or replace expressions. In these cases, we need to match a sequence node since they are the only AST nodes that contain statements. To match sequence nodes we need to specify the temporaries as well as the statements. To match the temporaries, we can use pattern variable nodes and actual temporary variable nodes. A pattern variable node will match a single temporary, but adding a `@` character to the pattern variable makes it match 0 or more temporaries. Similarly, we can use patterns to match statement nodes. If we add a `.` character to our pattern expression, it makes the pattern match any statement. Additionally, if we add a `@` character to the `.` character, then we can match 0 or more statements. In the following example, we convert two identical statements into a `2 timesRepeat:` statement:"
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:45:13.068336-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:45:13.068336-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "mndrJQ3+DQCLkiKlBvTZGA=="
				},
				"exampleSelector" : "twoTimesRepeat",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T08:48:55.168334-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T09:45:09.559599-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "o3GoMg3+DQCLnCg3BvTZGA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Finally, we can match blocks and methods using patterns. For a block, we specify the arguments using actual variable names or pattern variables. If the pattern variable contains an `@` character, then it matches 0 or more argument variables. For methods, we need to specify the method name. Either we can use actual message names or we can use pattern keywords like we did for pattern messages above. Inside the block or method, we need to specify the sequence node to match the whole block or method. The following example converts an `at:put:` method into a `put:at:` method by switching the arguments. To setup the rewriter we need to use the {{gtMethod:RBParseTreeRewriter>>#replaceMethod:with:}} message. This lets the parser know that the expression provided is a method and not an expression."
			},
			{
				"__type" : "exampleSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T09:38:52.284551-05:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-21T09:38:52.284551-05:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "o85M5Q3+DQCYp7Y3BvTZGA=="
				},
				"exampleSelector" : "convertAtPutMethodToPutAt",
				"previewHeight" : 200,
				"previewShowSelector" : "gtViewsFor:",
				"exampleBehaviorName" : "GtRBParseTreeRewriterExamples",
				"codeExpanded" : true,
				"previewExpanded" : false,
				"noCode" : false
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-10-20T09:57:59.312018-05:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-10-20T09:57:59.312018-05:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "Examples for rewriting Pharo code"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "7a7fae09-fafd-0d00-8afb-6ee906f4d918"
	}
}